[
  {
    "objectID": "posts/pca-curva-juros/pca-curva-juros.html",
    "href": "posts/pca-curva-juros/pca-curva-juros.html",
    "title": "Curva de juros: um conto de três fatores",
    "section": "",
    "text": "A ideia do notebook é a partir do dos contratos futuros de DI construir a estrutura a termo de juros da economia brasileira. Por fim, vamos aplicar uma Análise de Componentes Principais e encontrar os fatores de risco latentes na curva de juros. Se você já ouviu falar em Nelson-Siegel, você já deve imaginar quais são.\nNa análise, serão usados os ajustes dos contratos negociados na B3 — e tem bastante coisa, de boi-gordo a câmbio, de cupom cambial a café. Os dados podem ser obtidos facilmente por meio do biblioteca rb3. Para manipular os dados de juros e interpolar as taxas, vou utilizar o pacote fixedincome. Ambos foram desenvolvidos pelo Wilson Freitas."
  },
  {
    "objectID": "posts/pca-curva-juros/pca-curva-juros.html#interpolando-as-curvas-e-fixando-as-maturidades",
    "href": "posts/pca-curva-juros/pca-curva-juros.html#interpolando-as-curvas-e-fixando-as-maturidades",
    "title": "Curva de juros: um conto de três fatores",
    "section": "Interpolando as curvas e fixando as maturidades",
    "text": "Interpolando as curvas e fixando as maturidades\nNote que esta é uma estrutura dinâmica. O tempo passa, os contratos vencem. Para continuar o exercício, nós precisamos fixar as maturidades para trabalhar com taxas de 1,2,3 anos.\n\nultima_refdate_plot = di1_data |&gt;\nfilter(refdate == max(refdate) | refdate %in% c('2023-09-01', '2023-01-03', '2022-10-04', '2020-04-01')) |&gt;\nmutate(refdate = as.factor(refdate)) |&gt; \nggplot() + \n   geom_point(aes(x = date_vencimento, y = tx, colour = refdate)) +\n   geom_line(aes(x = date_vencimento, y = tx, colour = refdate)) +\n   theme_minimal() +\n   scale_y_continuous(labels = scales::percent) +\n   scale_colour_manual('', values = paleta_cores) +\n   labs(y = 'Taxa', x = 'Data de Vencimento do Contrato')\n\nggplotly(ultima_refdate_plot)\n\n\n\n\n\nPara isso, é necessário interpolar as curvas — não se assuste, você está apenas ligando os vértices para cada data de referência. Assim, será possível pegar du_ate_vcto fixos de cada refdate. O pacote fixedincome facilita o processo. Vamos criar um objeto SpotRateCurve para cada data de referência, adicionar um método de interpolação e salvar apenas os vértices de interesse.\nQuanto aos parâmetros: “discrete” é porque o método de capitalização utilizado é o discreto, “business/252” é porque nossa curva de juros é anualizada em 252 dias úteis e “Brazil/ANBIMA” para utilizar o calendário da ANBIMA para definir os dias úteis.\n\ndi1_data_l = di1_data |&gt; \n  arrange(refdate, date_vencimento_adj) |&gt;\n  split(di1_data$refdate) |&gt;\n  purrr::map(function(x){\n    curve = fixedincome::spotratecurve(x$tx, x$du_ate_vcto, refdate = unique(x$refdate),\n                               'discrete', 'business/252', 'Brazil/ANBIMA')\n    interpolation(curve) &lt;- fixedincome::interp_naturalspline()\n    curve\n  })\n\ncurvaDI1 = tibble::tibble(refdate = names(di1_data_l), curvadi1 = di1_data_l) \n\n# Agora que temos um estrutura a termo interpolada para cada data de referência, conseguimos por exemplo, pegar a taxa de um ano para cada data de referência\ndus = c(252, 252*2, 252*3, 252*4, 252*5, 252*6, 252*7, 252*8, 252*9, 252*10)\n\ndi1_constant_maturity = map_dfr(di1_data_l, \n          .f = function(x){\n            tx = x[[dus]] |&gt; as.numeric()\n            tibble(refdate = x@refdate,\n                   maturity = dus,\n                   tx = tx)\n          }\n)\n\nPara ilustrar o problema que acabamos de resolver, compare o gráfico abaixo com o primeiro gráfico que nós fixemos. Agora o gráfico não desloca mais, temos as taxas de 252 dias (1 ano), 504 dias (2 anos) e assim sucessivamente para cada ponto no tempo.\nCom os dados organizados dessa forma conseguimos dar uma brincada e construir algumas visualizações interessantes.\n\n# Gráfico com datas de referência selecionadas\np1 = di1_constant_maturity |&gt; \nfilter(refdate == max(refdate) | refdate %in% c('2023-09-01', '2023-01-03', '2022-01-03', '2021-01-04','2020-04-01', '2019-02-11')) |&gt;\nmutate(refdate = as.factor(refdate)) |&gt;\n    ggplot() +\n    geom_point(aes(x = maturity, y = tx, colour = refdate), show.legend = F) +\n   geom_line(aes(x = maturity, y = tx, colour = refdate), show.legend = F) +\n   theme(legend.position = 'none') +\n   theme_minimal() +\n   scale_x_continuous(breaks = dus) +\n   scale_y_continuous(labels = scales::percent) +\n   scale_colour_manual('', values = paleta_cores) +\n   labs(y = 'Taxa', x = 'DU')\n\nggplotly(p1) \n# Grafico interativo\np2 = di1_constant_maturity |&gt;\n    group_by(refdate_month = month(refdate), refdate_year = year(refdate)) |&gt; # Pegando apenas o final de cada mês para não ficar muito pesado\n    filter(refdate == max(refdate)) |&gt;\n    ungroup() |&gt;\n    # mutate(refdate = as.factor(format(refdate, '%b-%y'))) |&gt;\n    ggplot() +\n      geom_point(aes(x = maturity, y = tx, frame = refdate), size = 2, colour = paleta_cores[1], show.legend = F)+\n      geom_line(aes(x = maturity, y = tx, frame = refdate), size = 1, colour = paleta_cores[1], show.legend = F) +\n      theme_minimal() +\n      scale_x_continuous(breaks = dus) +\n      scale_y_continuous(labels = scales::percent, n.breaks = 10) +\n      # scale_colour_manual('', values = paleta_cores) +\n      labs(y = 'Taxa', x = 'DU')\n\n# Você pode criar um plotly com um seletor de datas\nggplotly(p2) |&gt;\nanimation_opts(1000, easing = 'elastic', redraw = FALSE) |&gt;\nanimation_button(x = 1, xanchor = 'right', y = 0, yanchor = 'bottom') \n#|&gt;\n# add_title(title = 'Curva de Juros', subtitle_str = '% a.a.')\n\n# Todos os vértices ao longo do tempo\np3 = di1_constant_maturity |&gt;\n    mutate(maturity = as.factor(maturity)) |&gt;\n    ggplot() +\n    geom_line(aes(x = refdate, y = tx, colour = maturity)) +\n   theme_minimal() +\n   scale_y_continuous(labels = scales::percent) +\n   scale_colour_manual('', values = paleta_cores) +\n   labs(y = 'Taxa', x = 'Data')\n\nggplotly(p3) \n#|&gt;\n# add_title(title = 'Curva de Juros', subtitle_str = '% a.a. por vértice')\n\n# Superfície com o Plotly\ndi1_constant_maturity_xts = di1_constant_maturity |&gt;\n  pivot_wider(id_cols = refdate, names_from = maturity, values_from = tx)\ndi1_constant_maturity_xts = xts(di1_constant_maturity_xts |&gt; select(-refdate), order.by = di1_constant_maturity_xts$refdate)\n\nplot_ly(z = ~di1_constant_maturity_xts, y = index(di1_constant_maturity_xts), x = names(di1_constant_maturity_xts),\n         colorbar = list(title = \"Taxa\")) %&gt;%\n  add_surface()  %&gt;%\n  layout(scene = list(\n           legend = list('Taxa'),\n           xaxis = list(title = \"DU\"),\n           yaxis = list(title = \"Data\"),\n           zaxis = list(title = \"Taxa\")\n         )) #|&gt;\n  # add_title(title = 'Curva de Juros', subtitle_str = '% a.a., por maturidade e data de referência')"
  },
  {
    "objectID": "posts/pca-curva-juros/pca-curva-juros.html#analisando-os-componentes-principais",
    "href": "posts/pca-curva-juros/pca-curva-juros.html#analisando-os-componentes-principais",
    "title": "Curva de juros: um conto de três fatores",
    "section": "Analisando os componentes principais",
    "text": "Analisando os componentes principais\nVamos aos resultados.\nPrimeiramente, sim, apenas 1 componente principal explica 97% da variabilidade em todos os 10 vértices que selecionamos da estrutura a termo. Os 3 primeiros componentes explicam praticamente 100%.\n\n# Contribuição, Desvio Padrão por Componente principal\nreactable(di1_pca$contrib |&gt; filter(PC %in% as.character(c(1:5))),\n          defaultColDef = colDef(format = colFormat(digits = 4)),compact = T, pagination = F, fullWidth = T) |&gt;\n  reactablefmtr::add_title('Contribuição e Desvio Padrão por Componente Principal', font_size = 16)\n\n\nContribuição e Desvio Padrão por Componente Principal\n\n\n\n\nMas o que tem em cada componente? Pois é, essa é a parte que mais me deixou curioso como um eterno aprendiz e iniciante em 999 coisas, embora para outras pessoas seja óbvio.\nPara isso, vejamos as correlações dos componentes com as séries originais, bem como os loadings ou auto-vetores de cada componente. O loading nada mais é que a transformação linear que você aplica em cada série para obter o componente principal. Na prática, estamos construindo uma combinação linear de vértices. Cada combinação é linearmente independente da outra.\n\n# Correlação entre o Componente Principal e o Vértice da Estrutura a Termo\nreactable(di1_pca$correlation[,c(1:5)]*-1,\n          defaultColDef = colDef(format = colFormat(digits = 2), style = reactablefmtr::color_scales(di1_pca$correlation*-1)), compact = T, pagination = F, fullWidth = T) |&gt;\n  reactablefmtr::add_title('Correlação entre os PCs e os Vértice do DI', font_size = 16)\n\n\nCorrelação entre os PCs e os Vértice do DI\n\n\n\n\nO primeiro componente (PC1 ou Dim.1) tem alta correlação com todos os vértices e ela é bastante parecida em magnitude. De fato, como podemos ver no gráfico com os loadings, ele é uma combinação linear de pesos iguais de todos os vértices. Uma coisa que vou tentar mostrar posteriormente, é que, na prática, é como se estivessemos fazendo uma média de todos os vértices e extraindo um nível médio da curva naquela data de referência.\nO segundo componente (PC2) tem correlação negativa com os vértices curtos e positiva com os vértices mais longos. É como se estivéssemos pegando a parte longa da curva e subtraindo da parte curta. Dito de outra forma, o PC2 é um fator que traz a inclinação da curva de juros.\nPor fim, o PC3 ficou um pouco menos óbvio. O plot dos loadings tem quase um formato de U invertido, capturando um terceiro fator que é a curvatura da curva de juros.\n\n# Loadings \nf=paste0(1:10, 'Y')\ndf_loadings = (di1_pca$prcomp.res$rotation*-1) |&gt; as.data.frame()\ndf_loadings = df_loadings |&gt; mutate(vertice = rownames(df_loadings)) |&gt;\n  select(vertice, everything()) |&gt;\n  mutate(vertice = factor(vertice, levels = f))\n\np=df_loadings |&gt;\n  pivot_longer(cols = -1, names_to = 'PC', values_to = 'loading') |&gt;\n  filter(PC %in% c('PC1', 'PC2', 'PC3')) |&gt;\n  ggplot() +\n  geom_bar(stat = 'identity', aes(x = vertice, y = loading), fill = paleta_cores[6]) +\n  # geom_hline(aes(yintercept = 0), size = .5, linetype = 'dashed') +\n  theme_minimal() +\n  facet_wrap(~PC) +\n  labs(x = 'Vértice', y = '')\nggplotly(p) |&gt;\n  add_title(title = 'Loadings dos componentes principais', subtitle_str = '')\n\n\n\n\n\nDe fato, essas ideias estão bem documentadas na literatura de finanças. Com esses 3 fatores, devemos ser capazes de reproduzir toda a estrutura a termo da taxa de juros no tempo."
  },
  {
    "objectID": "posts/pca-curva-juros/pca-curva-juros.html#comparando-os-componentes-principais-com-média-inclinação-e-curvatura",
    "href": "posts/pca-curva-juros/pca-curva-juros.html#comparando-os-componentes-principais-com-média-inclinação-e-curvatura",
    "title": "Curva de juros: um conto de três fatores",
    "section": "Comparando os componentes principais com média, inclinação e curvatura",
    "text": "Comparando os componentes principais com média, inclinação e curvatura\nAgora, nós vamos comparar o primeiro componente principal (PC1) com uma métrica de nível da curva de juros. O PC2 com uma medida de inclinação. E, por fim, o PC3 com uma métrica de curvatura.\nVamos definir a inclinação como sendo a difernça entre os juros de 10Y e os juros de 1Y. A curvatura será dada pelo dobro da média dos vértices de 4,5,6 e 7 anos subtraídos da soma dos dos juros de 1 e 10 anos. Já o nível é a média simples de todos os vértices.\n\n#  Para isso vamos calcular os fatores nível, inclinação e curvatura com os dados originais\nfatores_curva = di1_constant_maturity_wide |&gt;\n  mutate(nivel = rowMeans(di1_constant_maturity_wide[,-1]),\n         inclinacao = `10Y`-`1Y`) |&gt;\n  rowwise() |&gt;\n  mutate(curvatura = 2*mean(c(`4Y`,`5Y`,`6Y`,`7Y`)) - (`1Y`+`10Y`)) |&gt;\n  ungroup() |&gt;\n  select(refdate, nivel, inclinacao, curvatura)\n\n# Merge com os componentes principais\nfatores_vs_pca = merge(di1_pca$PCs, fatores_curva, by = 'refdate')\n\nfatores_vs_pca_long = fatores_vs_pca |&gt;\n  pivot_longer(cols = -1)\n\nay &lt;- list(\n  #tickfont = list(color = \"red\"),\n  overlaying = \"y\",\n  side = \"right\"\n)\n\n# PC1 vs. Nível (Média das Vértices)\nplot_ly(data = fatores_vs_pca) %&gt;%\n  add_lines(x = ~refdate, y = ~nivel, name = \"Nível\",type = \"scatter\", mode = \"lines\",\n            line = list(color = paleta_cores[5])) %&gt;%\n  add_lines(x = ~refdate, y = ~PC1, name = \"PC1\", yaxis = \"y2\",type = \"scatter\", mode = \"lines\", line = list(color = paleta_cores[4])) %&gt;%\n  layout(\n    yaxis2 = ay,\n    xaxis = list(title=\"Date\", ticks=fatores_vs_pca$Date),\n    yaxis = list(title = '')\n  ) |&gt; add_title(title_str = 'PC1 vs Nível da Curva de Juros',\n                 subtitle = 'nível (eixo esq.), PC1 (eixo dir.)')\n# PC2 vs. Inclinação (10Y - 1Y)\nplot_ly(data = fatores_vs_pca) %&gt;%\n  add_lines(x = ~refdate, y = ~inclinacao, name = \"Inclinação\",type = \"scatter\", mode = \"lines\", line = list(color = paleta_cores[5])) %&gt;%\n  add_lines(x = ~refdate, y = ~PC2, name = \"PC2\", yaxis = \"y2\",type = \"scatter\", mode = \"lines\",line = list(color = paleta_cores[4])) %&gt;%\n  layout(\n    yaxis2 = ay,\n    xaxis = list(title=\"Date\", ticks=fatores_vs_pca$Date),\n    yaxis = list(title = '')\n  ) |&gt; add_title(title_str = 'PC2 vs Inclinação da Curva de Juros',\n                   subtitle = 'inclinação (eixo esq.), PC2 (eixo dir.)')\n# PC3 vs. Curvatura (Média(2Y,3Y,4Y,5Y,6Y) - (1Y+10Y))\nplot_ly(data = fatores_vs_pca) %&gt;%\n  add_lines(x = ~refdate, y = ~curvatura, name = \"Curvatura\",type = \"scatter\", mode = \"lines\",line = list(color = paleta_cores[5])) %&gt;%\n  add_lines(x = ~refdate, y = ~PC3, name = \"PC3\", yaxis = \"y2\",type = \"scatter\", mode = \"lines\",line = list(color = paleta_cores[4])) %&gt;%\n  layout(\n    yaxis2 = ay,\n    xaxis = list(title=\"Date\", ticks=fatores_vs_pca$Date),\n    yaxis = list(title = '')\n  ) |&gt; add_title(title_str = 'PC3 vs Curvatura da Curva de Juros',\n                 subtitle = 'curvatura (eixo esq.), PC3 (eixo dir.)')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComo pode ser visto, os resultados são bastante satisfatórios para os dois primeiros componentes. No caso da curvatura, o fit já não é tão bom, sobretudo no passado. É possível melhorar fazendo 2*(3Y) - (1Y+10Y) — replicando um pouco mais fielmente os loadings obtidos para o PC3, entretanto imagino que a ideia de “curvatura” perderia um pouco o sentido. Sendo assim, vamos manter o resultado que encontramos. Um possível motivo para o shape dos loadings do terceiro componente não ter sido o esperado diante da literatura seja as discrepâncias de liquidez entre os vértices.\nEnfim, essa é uma das intersecções mais interessantes que tive contato entre técnicas de Machine Learning e Finanças.\nEnfim, obrigado se leu até aqui e se você encontrou algum erro ou alguma coisa muito estranha, pode me mandar mensagem ;)."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello, i’m Victor Hugo\n26 years old, brazilian born and raised in the interior of São Paulo State. I like to create,solve problems and help my coworkers with their main daily chalenges. I am very curious and fastleaner. Today, I work in data, economics finance, and programming. I’m very interested in quantitative finance, data science and macroeconomics. Solving business problems with data is my passion."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Serendipius Chronicles",
    "section": "",
    "text": "Curva de juros: um conto de três fatores\n\n\n\n\n\n\n\nFinanças\n\n\nMachine Learning\n\n\nJuros\n\n\n\n\n\n\n\n\n\n\n\nNov 20, 2023\n\n\nVictor Souza\n\n\n\n\n\n\nNo matching items"
  }
]